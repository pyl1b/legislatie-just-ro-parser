{% extends "base.html" %}
{% block content %}
<h1>Leropa RAG Demo</h1>
<p><a href="/documents?format=html">Documents</a></p>

<div class="mb-4">
  <h2>Ask a question</h2>
  <form id="ask-form" class="input-group">
    <input type="text" id="question" name="question" class="form-control" placeholder="Your question" aria-label="Question" />
    <button class="btn btn-primary" type="submit">Ask</button>
  </form>
  <textarea id="answer" class="form-control mt-3" rows="4" readonly></textarea>
  <ul id="citations" class="list-group mt-3"></ul>
</div>

<div class="mb-4">
  <h2>Search documents</h2>
  <form id="search-form" class="input-group">
    <input type="text" id="query" name="query" class="form-control" placeholder="Search query" aria-label="Search query" />
    <button class="btn btn-secondary" type="submit">Search</button>
  </form>
  <ul id="hits" class="list-group mt-3"></ul>
</div>

<div id="progress" class="d-none mt-3">
  <div class="progress">
    <div class="progress-bar progress-bar-striped progress-bar-animated" style="width: 100%"></div>
  </div>
  <div class="text-muted mt-1">Waiting for reply...</div>
  
</div>

<script>
const progressEl = document.getElementById('progress');

function showProgress(show) {
  progressEl.classList.toggle('d-none', !show);
}

const askForm = document.getElementById('ask-form');
askForm.addEventListener('submit', async (e) => {
  e.preventDefault();

  // Read the question from the input field.

  const question = document.getElementById('question').value;

  try {
    showProgress(true);
    // Perform a POST request to the ask endpoint.

    const resp = await fetch('/rag/ask', {
      method: 'POST',
      headers: {'Content-Type': 'application/json'},
      body: JSON.stringify({question}),
    });

    // Throw an error if the response is not successful.

    if (!resp.ok) {
      const errText = await resp.text();
      throw new Error(errText || resp.statusText);
    }

    // Parse the JSON answer and display it to the user.

    const data = await resp.json();

    // Populate the textarea with the answer text.

    document.getElementById('answer').value = data.text || '';

    // Clear existing citation list before adding new items.

    const citationList = document.getElementById('citations');
    citationList.innerHTML = '';

    // Add each context as a citation linking to the document details page.

    (data.contexts || []).forEach((ctx, idx) => {
      const src = ctx.source_file || '';
      const verId = src.split('/').pop().split('.')[0];
      const url = `/documents/${verId}?format=html#${ctx.article_id}`;
      const li = document.createElement('li');
      li.className = 'list-group-item';
      const a = document.createElement('a');
      a.href = url;
      a.textContent = `[${idx + 1}] Art. ${ctx.label}`;
      li.appendChild(a);
      citationList.appendChild(li);
    });
  } catch (err) {
    // Show a toast notification for any errors.

    showToast(err.message);
  } finally {
    showProgress(false);
  }
});

const searchForm = document.getElementById('search-form');
searchForm.addEventListener('submit', async (e) => {
  e.preventDefault();

  // Read the search query from the input field.

  const query = document.getElementById('query').value;

  try {
    showProgress(true);
    // Perform a POST request to the search endpoint.

    const resp = await fetch('/rag/search', {
      method: 'POST',
      headers: {'Content-Type': 'application/json'},
      body: JSON.stringify({query}),
    });

    // Throw an error if the response is not successful.

    if (!resp.ok) {
      const errText = await resp.text();
      throw new Error(errText || resp.statusText);
    }

    // Parse the JSON hits and populate the list with results.

    const hits = await resp.json();
    const list = document.getElementById('hits');
    list.innerHTML = '';
    hits.forEach((hit) => {
      const li = document.createElement('li');
      li.className = 'list-group-item';
      li.textContent = hit.text || JSON.stringify(hit);
      list.appendChild(li);
    });
  } catch (err) {
    // Show a toast notification for any errors.

    showToast(err.message);
  } finally {
    showProgress(false);
  }
});
</script>
{% endblock %}
